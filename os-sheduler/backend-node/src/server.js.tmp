const path = require(\"path\");
// backend-node/src/server.js
const express = require('express');
const http = require('http');
const { spawn } = require('child_process');
const readline = require('readline');
const cors = require('cors');
const { Server } = require('socket.io');

const SCHEDULER_PATH = '../scheduler-c/bin/scheduler'; // relative to backend-node/src
let schedulerProc = null;
let lastEvents = []; // last events for quick status
const MAX_EVENTS = 1000;

const app = express();
app.use(express.json());
app.use(cors());

const server = http.createServer(app);
const io = new Server(server, { cors: { origin: '*' } });

io.on('connection', (socket) => {
  console.log('socket connected', socket.id);
  // send recent events on connect
  socket.emit('recentEvents', lastEvents);
});

function pushEvent(ev) {
  lastEvents.push(ev);
  if (lastEvents.length > MAX_EVENTS) lastEvents.shift();
  io.emit('scheduler:event', ev);
}

/* Spawn scheduler with args: mode + (quantum) + jobs... */
function startScheduler({ mode, quantum, jobs }) {
  if (schedulerProc) throw new Error('Scheduler already running');
  const args = [];
  if (mode === 'rr') {
    args.push('rr', String(quantum || 200), ...jobs);
  } else {
    args.push('fcfs', ...jobs);
  }

  // resolve path relative to this file
  const proc = spawn(SCHEDULER_PATH, args, { cwd: __dirname, stdio: ['ignore', 'pipe', 'pipe'] });
  schedulerProc = proc;

  const rl = readline.createInterface({ input: proc.stdout });
  rl.on('line', (line) => {
    try {
      const parsed = JSON.parse(line);
      pushEvent(parsed);
    } catch (err) {
      // keep stderr for human debug, but do not crash
      console.error('JSON parse error for line:', line, err.message);
    }
  });

  proc.stderr.on('data', (chunk) => {
    // forward to socket (as log) and print to server console
    const text = chunk.toString();
    const ev = { type: 'log', text, timestamp: Date.now() / 1000 };
    pushEvent(ev);
    console.error('scheduler stderr:', text.trim());
  });

  proc.on('exit', (code, sig) => {
    console.log(`scheduler exited code=${code} sig=${sig}`);
    pushEvent({ type: 'scheduler_exited', code, sig, timestamp: Date.now() / 1000 });
    schedulerProc = null;
  });

  return proc.pid;
}

/* Stop scheduler process if running */
function stopScheduler() {
  if (!schedulerProc) return false;
  schedulerProc.kill('SIGKILL');
  schedulerProc = null;
  return true;
}

/* API endpoints */
app.post('/start', (req, res) => {
  try {
    const { mode, quantum, jobs } = req.body;
    if (!mode || !jobs || !Array.isArray(jobs) || jobs.length === 0) {
      return res.status(400).json({ error: 'missing mode or jobs' });
    }
    const pid = startScheduler({ mode, quantum, jobs });
    return res.json({ ok: true, pid });
  } catch (err) {
    console.error('start error', err);
    return res.status(500).json({ error: err.message });
  }
});

app.post('/stop', (req, res) => {
  try {
    if (!schedulerProc) return res.json({ ok: false, message: 'not running' });
    stopScheduler();
    return res.json({ ok: true });
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
});

app.get('/status', (req, res) => {
  res.json({
    running: !!schedulerProc,
    pid: schedulerProc ? schedulerProc.pid : null,
    recentEvents: lastEvents.slice(-50),
  });
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`Backend listening on port ${PORT}`);
});
