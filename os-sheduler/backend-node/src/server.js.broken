cat > src/server.js <<'JS'
/*
  backend-node/src/server.js
  Node backend with Socket.IO + SQLite persistence for scheduler runs/events.
  - Creates data/runs.db
  - Tables: runs, events
  - Endpoints: /start, /stop, /status, /runs, /runs/:id, /runs/:id/events
*/

const express = require('express');
const http = require('http');
const { spawn } = require('child_process');
const readline = require('readline');
const cors = require('cors');
const { Server } = require('socket.io');
const path = require('path');
const fs = require('fs');
const sqlite3 = require('sqlite3').verbose();

// Resolve scheduler binary robustly (relative to this file)
const SCHEDULER_PATH = path.join(__dirname, '..', '..', 'scheduler-c', 'bin', 'scheduler');
const DB_DIR = path.join(__dirname, '..', 'data');
const DB_FILE = path.join(DB_DIR, 'runs.db');

if (!fs.existsSync(DB_DIR)) fs.mkdirSync(DB_DIR, { recursive: true });

// --- SQLite initialization ---
const db = new sqlite3.Database(DB_FILE);

// Create schema if not exists
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS runs (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      mode TEXT,
      quantum INTEGER,
      jobs TEXT,
      pid INTEGER,
      started_at REAL,
      ended_at REAL,
      exit_code INTEGER
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS events (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      run_id INTEGER,
      timestamp REAL,
      type TEXT,
      job_id INTEGER,
      pid INTEGER,
      data TEXT,
      FOREIGN KEY (run_id) REFERENCES runs(id) ON DELETE CASCADE
    )
  `);

  db.run(`CREATE INDEX IF NOT EXISTS idx_events_run ON events (run_id, timestamp)`);
});

function insertEventToDb(runId, ev) {
  if (!runId) return;
  const ts = ev.timestamp ? Number(ev.timestamp) : (Date.now() / 1000);
  const type = ev.type || null;
  const job_id = typeof ev.job_id !== 'undefined' ? ev.job_id : null;
  const pid = typeof ev.pid !== 'undefined' ? ev.pid : null;
  const data = JSON.stringify(ev);
  const sql = `INSERT INTO events (run_id, timestamp, type, job_id, pid, data) VALUES (?, ?, ?, ?, ?, ?)`;
  db.run(sql, [runId, ts, type, job_id, pid, data], (err) => {
    if (err) console.error('DB insert event error:', err);
  });
}

const app = express();
app.use(express.json());
app.use(cors());

const server = http.createServer(app);
const io = new Server(server, { cors: { origin: '*' } });

let lastEvents = [];
const MAX_EVENTS = 5000;

let schedulerProc = null;
let currentRunId = null;
let schedulerTimestampOffset = null;
let lastSchedulerPid = null;

io.on('connection', (socket) => {
  console.log('socket connected', socket.id);
  socket.emit('recentEvents', lastEvents);
});

function pushEvent(ev) {
  if (ev && typeof ev.timestamp === 'string') {
    const n = Number(ev.timestamp);
    if (!Number.isNaN(n)) ev.timestamp = n;
  }
  lastEvents.push(ev);
  if (lastEvents.length > MAX_EVENTS) lastEvents.shift();
  if (currentRunId) insertEventToDb(currentRunId, ev);
  io.emit('scheduler:event', ev);
}

function normalizeSchedulerTimestamp(parsed) {
  if (!parsed || typeof parsed.timestamp !== 'number') {
    parsed.timestamp = Date.now() / 1000;
    return parsed;
  }
  const ts = parsed.timestamp;
  if (ts < 1e6) {
    if (schedulerTimestampOffset === null) {
      schedulerTimestampOffset = (Date.now() / 1000) - ts;
      console.log('Computed schedulerTimestampOffset =', schedulerTimestampOffset);
    }
    parsed.timestamp = ts + schedulerTimestampOffset;
  }
  return parsed;
}

function startSchedulerProcess({ mode, quantum, jobs, runId }) {
  const args = [];
  if (mode === 'rr') {
    args.push('rr', String(quantum || 200), ...jobs);
  } else {
    args.push('fcfs', ...jobs);
  }

  const proc = spawn(SCHEDULER_PATH, args, { cwd: path.join(__dirname, '..'), stdio: ['pipe', 'pipe', 'pipe'] });
  schedulerProc = proc;
  lastSchedulerPid = proc.pid;
  currentRunId = runId;

  const rl = readline.createInterface({ input: proc.stdout });
  rl.on('line', (line) => {
    try {
      const parsed = JSON.parse(line.trim());
      normalizeSchedulerTimestamp(parsed);
      pushEvent(parsed);
    } catch (err) {
      console.error('Failed to parse scheduler stdout line as JSON:', line, err.message);
      const ev = { type: 'log', text: line, timestamp: Date.now() / 1000 };
      pushEvent(ev);
    }
  });

  proc.stderr.on('data', (chunk) => {
    const text = chunk.toString();
    text.split(/\r?\n/).filter(Boolean).forEach(line => {
      const ev = { type: 'log', text: line + '\n', timestamp: Date.now() / 1000 };
      pushEvent(ev);
    });
  });

  proc.on('exit', (code, sig) => {
    console.log(`scheduler exited code=${code} sig=${sig}`);
    const endedAt = Date.now() / 1000;
    if (currentRunId) {
      db.run(`UPDATE runs SET ended_at = ?, exit_code = ? WHERE id = ?`, [endedAt, code, currentRunId], (err) => {
        if (err) console.error('DB error updating run end', err);
      });
    }
    pushEvent({ type: 'scheduler_exited', code, sig, timestamp: Date.now() / 1000 });
    schedulerProc = null;
    currentRunId = null;
    schedulerTimestampOffset = null;
    lastSchedulerPid = null;
  });

  return proc.pid;
}

app.post('/start', (req, res) => {
  try {
    const { mode, quantum, jobs } = req.body;
    if (!mode || !jobs || !Array.isArray(jobs) || jobs.length === 0) {
      return res.status(400).json({ error: 'missing mode or jobs' });
    }
    if (schedulerProc) return res.status(400).json({ error: 'scheduler already running' });

    const startedAt = Date.now() / 1000;
    const sql = `INSERT INTO runs (mode, quantum, jobs, pid, started_at) VALUES (?, ?, ?, ?, ?)`;
    db.run(sql, [mode, quantum || null, JSON.stringify(jobs), null, startedAt], function(err) {
      if (err) {
        console.error('DB insert run error', err);
        return res.status(500).json({ error: 'db error' });
      }
      const runId = this.lastID;
      try {
        const pid = startSchedulerProcess({ mode, quantum, jobs, runId });
        db.run(`UPDATE runs SET pid = ? WHERE id = ?`, [pid, runId], (err2) => {
          if (err2) console.error('DB update pid error', err2);
        });
        const ev = { type: 'run_started', run_id: runId, pid, mode, jobs, timestamp: Date.now() / 1000 };
        pushEvent(ev);
        return res.json({ ok: true, pid, run_id: runId });
      } catch (err) {
        console.error('startSchedulerProcess error', err);
        return res.status(500).json({ error: 'failed to spawn scheduler' });
      }
    });
  } catch (err) {
    console.error('start error', err);
    return res.status(500).json({ error: err.message });
  }
});

app.post('/stop', (req, res) => {
  try {
    if (!schedulerProc) return res.json({ ok: false, message: 'not running' });
    schedulerProc.kill('SIGKILL');
    return res.json({ ok: true });
  } catch (err) {
    console.error('stop error', err);
    return res.status(500).json({ error: err.message });
  }
});

app.post('/submit', (req, res) => {
  try {
    const { cmd } = req.body;
    if (!cmd) return res.status(400).json({ error: 'missing cmd' });
    if (!schedulerProc || !schedulerProc.stdin) return res.status(400).json({ error: 'scheduler not running or no stdin' });

    schedulerProc.stdin.write(`ADD ${cmd}\n`);
    const ev = { type: 'submit', cmd, timestamp: Date.now() / 1000 };
    pushEvent(ev);
    return res.json({ ok: true });
  } catch (err) {
    console.error('submit error', err);
    return res.status(500).json({ error: err.message });
  }
});

app.get('/status', (req, res) => {
  res.json({
    running: !!schedulerProc,
    pid: schedulerProc ? schedulerProc.pid : null,
    recentEvents: lastEvents.slice(-200),
  });
});

app.get('/runs', (req, res) => {
  db.all(`SELECT id, mode, quantum, jobs, pid, started_at, ended_at, exit_code FROM runs ORDER BY id DESC LIMIT 200`, [], (err, rows) => {
    if (err) return res.status(500).json({ error: err.message });
    const out = rows.map(r => ({ ...r, jobs: r.jobs ? JSON.parse(r.jobs) : [] }));
    res.json(out);
  });
});

app.get('/runs/:id', (req, res) => {
  const id = Number(req.params.id);
  db.get(`SELECT id, mode, quantum, jobs, pid, started_at, ended_at, exit_code FROM runs WHERE id = ?`, [id], (err, row) => {
    if (err) return res.status(500).json({ error: err.message });
    if (!row) return res.status(404).json({ error: 'not found' });
    row.jobs = row.jobs ? JSON.parse(row.jobs) : [];
    res.json(row);
  });
});

app.get('/runs/:id/events', (req, res) => {
  const id = Number(req.params.id);
  db.all(`SELECT id, timestamp, type, job_id, pid, data FROM events WHERE run_id = ? ORDER BY timestamp ASC`, [id], (err, rows) => {
    if (err) return res.status(500).json({ error: err.message });
    const out = rows.map(r => {
      let parsed = null;
      try { parsed = JSON.parse(r.data); } catch (e) { parsed = { raw: r.data }; }
      parsed._db_timestamp = r.timestamp;
      return parsed;
    });
    res.json(out);
  });
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`Backend listening on port ${PORT}`);
});
JS
